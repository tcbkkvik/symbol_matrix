package comp.torcb.misc;

import comp.torcb.algebra.matrix.Quaternion;
import comp.torcb.algebra.matrix.SymExpression;
import comp.torcb.algebra.matrix.SymMatrix;
import comp.torcb.algebra.misc.SymMatrixCodeGen;
import comp.torcb.algebra.matrix.Symbol;
import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;
import java.util.Map;
import java.util.stream.Stream;

import static comp.torcb.algebra.matrix.Symbol.ERR_DELTA;
import static org.junit.Assert.*;
import static org.junit.Assert.assertEquals;

/**
 * Unit test for simple App.
 */
@SuppressWarnings({"SpellCheckingInspection"})
public class AppTest {
    /**
     * Rigorous Test :-)
     */

    @Before
    public void before() {
        SymMatrix.PRINT_ALL_STREAM = System.out;
    }

    @Test
    public void symbol() {
        Symbol[] parsed = Stream.of("2", "-2", "-a", "", "3b")
                .map(Symbol::parse).toArray(Symbol[]::new);
        var s = new Symbol(2, "ab")
                .mul(new Symbol(-1, "c"));
        var s2 = s.assign(Map.of('a', .5));
        System.out.println(Arrays.toString(parsed));

        assertEquals("bc", s2.getBody());
        assertEquals(-1., s2.getNum(), ERR_DELTA);
    }

    @Test
    public void expression() {
        var e = SymExpression.parse("2a+1");
        var e2 = e.add(e);
        assertSame(e, e2);
        assertEquals(2, e.symbols().size());
        SymExpression e3 = SymExpression.parse("4a+2");
        assertEquals(e3, e);
        var e4 = e3.sub(new Symbol(4, "a"))
                .sub(SymExpression.parse("2"));
        SymExpression e5 = new SymExpression().mul(new SymExpression().add(1));
        assertEquals(e4, e5);
    }

    @Test
    public void matrix() {
        var sm = new SymMatrix("a+2b, c, d");
        var sm2 = sm.mul(1.5);
        var exp = new SymMatrix("1.5a+3b, 1.5c, 1.5d");
        assertEquals(exp, sm2);
        System.out.println(sm2);
        var mat = Quaternion.symRotationMatrix().subMatrix(0, 2, 0, 2);
        assertEquals(2, mat.noRows());
        assertEquals(2, mat.noCols());
    }

    public static double[][] calc1(double c, double x, double y, double z) {
        //Generated by SymMatrixCodeGen.toNumSource
        double c2 = c * c;
        double x2 = x * x;
        double y2 = y * y;
        double z2 = z * z;
        double cz = c * z;
        double xy = x * y;
        double cy = c * y;
        double xz = x * z;
        double cx = c * x;
        double yz = y * z;
        double m_0 = c2 + x2 - y2 - z2;
        double m_1 = -2 * cz + 2 * xy;
        double m_2 = 2 * cy + 2 * xz;
        double m_3 = 2 * cz + 2 * xy;
        double m_4 = c2 - x2 + y2 - z2;
        double m_5 = -2 * cx + 2 * yz;
        double m_6 = -2 * cy + 2 * xz;
        double m_7 = 2 * cx + 2 * yz;
        double m_8 = c2 - x2 - y2 + z2;
        return new double[][]{
                {m_0, m_1, m_2},
                {m_3, m_4, m_5},
                {m_6, m_7, m_8}
        };
    }

    @Test
    public void codeGen1() {
        String java = SymMatrixCodeGen.toNumSource(Quaternion.symRotationMatrix());
        System.out.println("\n" + java);
        var id = SymMatrix.identity(5);
        assertEquals(5, id.noCols());

        Quaternion q = Quaternion.fromAngleVector(Math.PI / 12, 1, 0, 0);
        var mat = new SymMatrix(
                calc1(q.c(), q.x(), q.y(), q.z())
        );
        SymExpression ex = mat.getMatrix()[0][0];
        assertEquals(1, ex.symbols().size());
        double cellNumericValue = ex.symbols().iterator().next().getNum();
        assertEquals(1, cellNumericValue, ERR_DELTA);
    }

    @Test
    public void quaternion() {
        Quaternion q0 = Quaternion.fromAngleVector(Math.PI / 12, 1, 0, 0);
        Quaternion q1 = q0.mul(q0);
        Quaternion q2 = Quaternion.fromAngleVector(Math.PI / 6, 1, 0, 0);

        SymMatrix vector0 = new SymMatrix(1, 2, 3);
        SymMatrix vector1 = vector0.mul(q2.toRotationMatrix());
        SymMatrix vector2 = vector1.mul(q2.conjugate().toRotationMatrix());

        assertEquals(q1, q2);
        assertEquals(vector0, vector2);

        //conjugate * qm == identity(1,0,0,0):
        var qmId = new SymMatrix("c, -x, -y,   -z").desc("conjugate")
                .mul(new SymMatrix(
                        "c, x, y,   z",
                        "-x, c, -z, y",
                        "-y, z, c, -x",
                        "-z, -y, x, c"
                ));
        assertEquals(1, qmId.noRows());
        assertEquals(4, qmId.noCols());
        SymExpression[] m0 = qmId.getMatrix()[0];
        for (int i = 0; i < m0.length; i++) {
            assertEquals(i == 0
                            ? "+cc+xx+yy+zz" //=1
                            : "0"
                    , m0[i].toString());
        }
    }

    public static double[][] calc2(double a, double b, double c, double e) {
        //Generated by SymMatrixCodeGen.toNumSource
        double a2 = a * a;
        double a3 = a2 * a;
        double a4 = a2 * a2;
        double b2 = b * b;
        double b3 = b2 * b;
        double b4 = b2 * b2;
        double c2 = c * c;
        double c3 = c2 * c;
        double c4 = c2 * c2;
        double e2 = e * e;
        double e3 = e2 * e;
        double e4 = e2 * e2;
        double a2b2c2 = a2 * b2 * c2;
        double a2c2 = a2 * c2;
        double a2e2 = a2 * e2;
        double a3bc = a3 * b * c;
        double ab3c3 = a * b3 * c3;
        double abc3 = a * b * c3;
        double abce2 = a * b * c * e2;
        double a3c = a3 * c;
        double ab2c3 = a * b2 * c3;
        double ac3 = a * c3;
        double ace2 = a * c * e2;
        double a3e = a3 * e;
        double ab2c2e = a * b2 * c2 * e;
        double ac2e = a * c2 * e;
        double ae3 = a * e3;
        double b4c4 = b4 * c4;
        double b2c4 = b2 * c4;
        double b2c2e2 = b2 * c2 * e2;
        double a2bc2 = a2 * b * c2;
        double b3c4 = b3 * c4;
        double bc4 = b * c4;
        double bc2e2 = b * c2 * e2;
        double a2bce = a2 * b * c * e;
        double b3c3e = b3 * c3 * e;
        double bc3e = b * c3 * e;
        double bce3 = b * c * e3;
        double c2e2 = c2 * e2;
        double a2ce = a2 * c * e;
        double b2c3e = b2 * c3 * e;
        double c3e = c3 * e;
        double ce3 = c * e3;
        double m_0 = a4 + 4 * a2b2c2 + a2c2 + 9 * a2e2;
        double m_1 = -2 * a3bc - 8 * ab3c3 - 2 * abc3 - 18 * abce2;
        double m_2 = a3c + 4 * ab2c3 + ac3 + 9 * ace2;
        double m_3 = 3 * a3e + 12 * ab2c2e + 3 * ac2e + 27 * ae3;
        double m_4 = 4 * a2b2c2 + 16 * b4c4 + 4 * b2c4 + 36 * b2c2e2;
        double m_5 = -2 * a2bc2 - 8 * b3c4 - 2 * bc4 - 18 * bc2e2;
        double m_6 = -6 * a2bce - 24 * b3c3e - 6 * bc3e - 54 * bce3;
        double m_7 = a2c2 + 4 * b2c4 + c4 + 9 * c2e2;
        double m_8 = 3 * a2ce + 12 * b2c3e + 3 * c3e + 27 * ce3;
        double m_9 = 9 * a2e2 + 36 * b2c2e2 + 9 * c2e2 + 81 * e4;
        return new double[][]{
                {m_0, m_1, m_2, m_3},
                {m_1, m_4, m_5, m_6},
                {m_2, m_5, m_7, m_8},
                {m_3, m_6, m_8, m_9}
        };
    }

    @Test
    public void codeGen2() {
        var symbolic = new SymMatrix("a,-2bc,c,3e")
                .map(m -> m.transpose().mul(m))
                .square();
        double a = 1;
        double b = 2;
        double c = 3;
        double e = -3;
        var java_calc2 = SymMatrixCodeGen.toNumSource(symbolic);
        System.out.println("\n" + java_calc2);
        //alt 1 symbolic -> toNumSource -> calc2(num)
        var mat1 = new SymMatrix(calc2(a, b, c, e)).desc("mat1");

        //alt 2 symbolic -> assign(num)
        var mat2 = symbolic.assign("abce", a, b, c, e).desc("mat2");

        //alt 3 matrix(num)
        var mat3 = new SymMatrix(a, -2 * b * c, c, 3 * e)
                .map(m -> m.transpose().mul(m))
                .square().desc("mat3");

        assertEquals(mat1, mat2);
        assertEquals(mat1, mat3);
    }

//    @Test
    @SuppressWarnings({"unused", "UnusedAssignment"})
    public void speedCompare() {
        double a = 1;
        double b = 2;
        double c = 3;
        double e = -3;
        var N = 100;
        SymMatrix.PRINT_ALL_STREAM = null;
        double[][] res;
        long t0 = System.nanoTime();
        for (int i = 0; i < N; i++) {
            res = calc2(a, b, c, e);
        }
        long t1 = System.nanoTime();
        SymMatrix res2;
        for (int i = 0; i < N; i++) {
            res2 = new SymMatrix(a, -2 * b * c, c, 3 * e)
                    .map(m -> m.transpose().mul(m))
                    .square();
        }
        long t2 = System.nanoTime();
        System.out.println("speedCompare, " + N + " iteratins:");
        System.out.printf("t[ms] generated calc2: %s%n", (t1 - t0) / 1000);
        System.out.printf("t[ms] num.multiply   : %s%n", (t2 - t1) / 1000);
    }

}
