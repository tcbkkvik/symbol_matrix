package comp.torcb.misc;

import comp.torcb.algebra.matrix.Quaternion;
import comp.torcb.algebra.matrix.SymExpression;
import comp.torcb.algebra.matrix.SymMatrix;
import comp.torcb.algebra.misc.SymMatrixCodeGen;
import comp.torcb.algebra.matrix.Symbol;
import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;
import java.util.Map;
import java.util.stream.Stream;

import static org.junit.Assert.*;

/**
 * Unit test for simple App.
 */
@SuppressWarnings({"UnaryPlus", "SpellCheckingInspection"})
public class AppTest {
    /**
     * Rigorous Test :-) todo
     */
    @Test
    public void shouldAnswerWithTrue() {
        assertTrue(true);
    }

    @Before
    public void before() {
        SymMatrix.PRINT_ALL_STREAM = System.out;
    }

    @Test
    public void symbol() {
        Symbol[] parsed = Stream.of("2", "-2", "-a", "", "3b")
                .map(Symbol::parse).toArray(Symbol[]::new);
        var s = new Symbol(2, "ab")
                .mul(new Symbol(-1, "c"));
        var s2 = s.assign(Map.of('a', .5));
        System.out.println(Arrays.toString(parsed));

        assertEquals("bc", s2.getBody());
        assertEquals(-1., s2.getNum(), 1e-5);
    }

    @Test
    public void expression() {
        var e = SymExpression.parse("2a+1");
        var e2 = e.add(e);
        assertSame(e, e2);
        assertEquals(2, e.symbols().size());
        SymExpression e3 = SymExpression.parse("4a+2");
        assertEquals(e3, e);
    }

    @Test
    public void matrix() {
        var sm = new SymMatrix("a+2b, c, d");
        var sm2 = sm.mul(1.5);
        var exp = new SymMatrix("1.5a+3b, 1.5c, 1.5d");
        assertEquals(exp, sm2);
        System.out.println(sm2);
    }

    static double[][] calc1(double c, double x, double y, double z) {
        //Generated by SCodeGen.toNumSource
        double cc = c * c;
        double cx = c * x;
        double cy = c * y;
        double cz = c * z;
        double xx = x * x;
        double xy = x * y;
        double xz = x * z;
        double yy = y * y;
        double yz = y * z;
        double zz = z * z;
        return new double[][]{
                {+cc + xx - yy - zz, -2.0 * cz + 2.0 * xy, +2.0 * cy + 2.0 * xz},
                {+2.0 * cz + 2.0 * xy, +cc - xx + yy - zz, -2.0 * cx + 2.0 * yz},
                {-2.0 * cy + 2.0 * xz, +2.0 * cx + 2.0 * yz, +cc - xx - yy + zz}
        };
    }

    @Test
    public void codeGen1() {
        String java = SymMatrixCodeGen.toNumSource(Quaternion.symRotationMatrix());
        System.out.println("\n" + java);
        var id = SymMatrix.identity(5);
        assertEquals(5, id.noCols());

        Quaternion q = Quaternion.normalize(Math.PI / 12, 1, 0, 0);
        var mat = new SymMatrix(
                calc1(q.c(), q.x(), q.y(), q.z())
        );
        SymExpression ex = mat.getMatrix()[0][0];
        assertEquals(1, ex.symbols().size());
        double cellNumericValue = ex.symbols().iterator().next().getNum();
        assertEquals(1, cellNumericValue, 1e-7);
    }

    public static double[][] calc2(double a, double b, double c, double e) {
        //Generated by SMatrixCodeGen.toNumSource
        double aaaa = a * a * a * a;
        double aaabc = a * a * a * b * c;
        double aaac = a * a * a * c;
        double aaae = a * a * a * e;
        double aabbcc = a * a * b * b * c * c;
        double aabcc = a * a * b * c * c;
        double aabce = a * a * b * c * e;
        double aacc = a * a * c * c;
        double aace = a * a * c * e;
        double aaee = a * a * e * e;
        double abbbccc = a * b * b * b * c * c * c;
        double abbccc = a * b * b * c * c * c;
        double abbcce = a * b * b * c * c * e;
        double abccc = a * b * c * c * c;
        double abcee = a * b * c * e * e;
        double accc = a * c * c * c;
        double acce = a * c * c * e;
        double acee = a * c * e * e;
        double aeee = a * e * e * e;
        double bbbbcccc = b * b * b * b * c * c * c * c;
        double bbbcccc = b * b * b * c * c * c * c;
        double bbbccce = b * b * b * c * c * c * e;
        double bbcccc = b * b * c * c * c * c;
        double bbccce = b * b * c * c * c * e;
        double bbccee = b * b * c * c * e * e;
        double bcccc = b * c * c * c * c;
        double bccce = b * c * c * c * e;
        double bccee = b * c * c * e * e;
        double bceee = b * c * e * e * e;
        double cccc = c * c * c * c;
        double ccce = c * c * c * e;
        double ccee = c * c * e * e;
        double ceee = c * e * e * e;
        double eeee = e * e * e * e;
        double comb1 = -2.0 * aaabc - 8.0 * abbbccc - 2.0 * abccc - 18.0 * abcee;
        double comb2 = +aaac + 4.0 * abbccc + accc + 9.0 * acee;
        double comb3 = +3.0 * aaae + 12.0 * abbcce + 3.0 * acce + 27.0 * aeee;
        double comb4 = -2.0 * aabcc - 8.0 * bbbcccc - 2.0 * bcccc - 18.0 * bccee;
        double comb5 = -6.0 * aabce - 24.0 * bbbccce - 6.0 * bccce - 54.0 * bceee;
        double comb6 = +3.0 * aace + 12.0 * bbccce + 3.0 * ccce + 27.0 * ceee;
        return new double[][]{
                {+aaaa + 4.0 * aabbcc + aacc + 9.0 * aaee, comb1, comb2, comb3},
                {comb1, +4.0 * aabbcc + 16.0 * bbbbcccc + 4.0 * bbcccc + 36.0 * bbccee, comb4, comb5},
                {comb2, comb4, +aacc + 4.0 * bbcccc + cccc + 9.0 * ccee, comb6},
                {comb3, comb5, comb6, +9.0 * aaee + 36.0 * bbccee + 9.0 * ccee + 81.0 * eeee}
        };
    }

    @Test
    public void codeGen2() {
        var symbolic = new SymMatrix("a,-2bc,c,3e")
                .map(m -> m.transpose().mul(m))
                .square();
        double a = 1;
        double b = 2;
        double c = 3;
        double e = -3;
        //alt 1 symbolic -> toNumSource -> calc2(num)
        var mat1 = new SymMatrix(calc2(a, b, c, e)).desc("mat1");

        //alt 2 symbolic -> assign(num)
        var mat2 = symbolic.assign("abce", a, b, c, e).desc("mat2");

        //alt 3 matrix(num)
        var mat3 = new SymMatrix(a, -2 * b * c, c, 3 * e)
                .map(m -> m.transpose().mul(m))
                .square().desc("mat3");

        assertEquals(mat1, mat2);
        assertEquals(mat1, mat3);
    }

}
