package comp.torcb.algebra.misc;

import comp.torcb.algebra.matrix.Quaternion;
import comp.torcb.algebra.matrix.SymExpression;
import comp.torcb.algebra.matrix.SymMatrix;
import comp.torcb.algebra.matrix.Symbol;

import java.util.*;
import java.util.stream.Collectors;


public class SymMatrixCodeGen {
    public static String toNumSource(SymMatrix sm) {
        final var _assignV2 = new Assignments();
        final var _outArrays = new StringBuilder();
        class Builder {
            private int row, col;
            private final Map<String, String> cellMap = new HashMap<>();
            private final StringBuilder cellAssignments = new StringBuilder();

            private String mapCell(String exp) {
                String label = cellMap.get(exp);
                if (label != null) return label;
                label = "m_" + cellMap.size();
                cellMap.put(exp, label);
                if (exp.startsWith("+")) {
                    exp = exp.substring(1);
                }
                //noinspection StringConcatenationInsideStringBufferAppend
                cellAssignments.append("    double " + label + " = " + exp + ";\n");
                return label;
            }

            void addCell(SymExpression exp) {
                if (++col == 1) {
                    if (row > 0) _outArrays.append(",\n        ");
                    _outArrays.append("{");
                } else {
                    _outArrays.append(", ");
                }
                var sb = new StringBuilder();
                for (Symbol sy : exp.symbols()) {
                    sb.append(sy.getNum() < 0 ? "-" : "+");
                    double abs = Math.abs(sy.getNum());
                    if (abs != 1.0) {
                        sb.append(Symbol.DECIMALFORMAT.format(abs)).append("*");
                    }
                    sb.append(_assignV2.add(sy.getBody()));
                }
//                _outArrays.append(sb);
                _outArrays.append(mapCell(sb.toString()));
            }

            void endRow() {
                ++row;
                col = 0;
                _outArrays.append("}");
            }
        }
        var builder = new Builder();
        for (var row : sm.getMatrix()) {
            for (SymExpression exp : row) builder.addCell(exp);
            builder.endRow();
        }
        return "public static double[][] calc(" + _assignV2.getMethodArgs() + ") {\n" +
               "    //Generated by " + SymMatrixCodeGen.class.getSimpleName() + ".toNumSource\n"
               + _assignV2.assignmentLines() + builder.cellAssignments +
               "    return new double[][] {\n" +
               "        " + _outArrays + "\n" +
               "    };\n" +
               "}\n";

    }

    static class CharPowers {
        final TreeMap<Integer, Integer> map = new TreeMap<>();
        final char ch;

        public CharPowers(char ch) {
            this.ch = ch;
        }

        public void build(final int len) {
            if (len < 2 || map.containsKey(len)) return;
            int a = Integer.highestOneBit(len);
            if (len == a) {
                build(a = len >> 1);
            } else {
                build(a);
                build(len - a);
            }
            map.put(len, a);
        }

        private static String i2s(int i) {
            return i > 1 ? "" + i : "";
        }

        @Override
        public String toString() {
            return getString("    ", ch);
        }

        @SuppressWarnings("SameParameterValue")
        private String getString(String pre, char ch) {
            var sb = new StringBuilder();
            for (var e : map.entrySet()) {
                int len = e.getKey();
                int a = e.getValue();
                sb.append(pre).append("double %s%d = %s%s * %s%s;\n"
                        .formatted(ch, len, ch, i2s(a), ch, i2s(len - a))
                );
            }
            return sb.toString();
        }
    }

    @SuppressWarnings("SpellCheckingInspection")
    static class Assignments {
        final Map<Character, CharPowers> assignMap = new TreeMap<>();
        final Map<String, String> cellMap = new TreeMap<>();//aaabcc -> a3bc2;   term -> var
        final List<String> assigns = new ArrayList<>();//double a3bc2 = a3*b*c2;  var = prod

        private String put(char c, int len) {
            assignMap.computeIfAbsent(c, _c -> new CharPowers(c)).build(len);
            return c + (len == 1 ? "" : "" + len);
        }

        public String getMethodArgs() {
            return assignMap.keySet().stream().map(c -> "double " + c).collect(Collectors.joining(", "));
        }

        public String add(String term) { //eg. aaabcc -> a3bc2=a3*b*c2;
            if (cellMap.containsKey(term)) {
                return cellMap.get(term);
            }
            List<String> list = new ArrayList<>();
            int len = 0;
            char prev = '?';
            for (char ch : term.toCharArray()) {
                if (len > 0 && prev != ch) {
                    list.add(put(prev, len));
                    len = 0;
                }
                ++len;
                prev = ch;
            }
            list.add(put(prev, len));
            String var = String.join("", list);
            cellMap.put(term, var);
            if (list.size() > 1) {
                String prod = String.join(" * ", list);
                assigns.add("    double " + var + " = " + prod + ";\n");
            }
            return var;
        }

        public String assignmentLines() {
            return assignMap.values().stream()
                           .map(String::valueOf)
                           .collect(Collectors.joining())
                   + String.join("", assigns);
        }
    }

    public static void main(String[] args) {
        String srcJava = toNumSource(Quaternion.symRotationMatrix());
        System.out.println(srcJava);
    }
}
